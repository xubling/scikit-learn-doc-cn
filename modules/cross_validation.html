
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
  
    <title>3.1. Cross-validation: 评估 estimator 的性能 &#8212; scikit-learn 0.18 documentation</title>
  <!-- htmltitle is before nature.css - we use this hack to load bootstrap first -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../_static/css/bootstrap.min.css" media="screen" />
  <link rel="stylesheet" href="../_static/css/bootstrap-responsive.css"/>

    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.18',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="scikit-learn 0.18 documentation" href="../index.html" />
    <link rel="up" title="3. Model selection and evaluation" href="../model_selection.html" />
    <link rel="next" title="3.2. Grid Search: Searching for estimator parameters" href="grid_search.html" />
    <link rel="prev" title="3. Model selection and evaluation" href="../model_selection.html" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="../_static/js/bootstrap.min.js" type="text/javascript"></script>
  <link rel="canonical" href="http://scikit-learn.org/stable/modules/cross_validation.html" />

  <script type="text/javascript">
    $("div.buttonNext, div.buttonPrevious").hover(
       function () {
           $(this).css('background-color', '#FF9C34');
       },
       function () {
           $(this).css('background-color', '#A7D6E2');
       }
    );
  </script>

  </head>
  <body role="document">

<div class="header-wrapper">
    <div class="header">
        <p class="logo"><a href="../index.html">
            <img src="../_static/scikit-learn-logo-small.png" alt="Logo"/>
        </a>
        </p><div class="navbar">
            <ul>
                <li><a href="../index.html">主页</a></li>
                <li><a href="../install.html">安装</a></li>
                <li class="btn-li"><div class="btn-group">
              <a href="../documentation.html">文档</a>
              <a class="btn dropdown-toggle" data-toggle="dropdown">
                 <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
            <li class="link-title">Scikit-learn 0.17 (stable)</li>
            <li><a href="../tutorial/index.html">入门指南</a></li>
            <li><a href="../user_guide.html">使用手册</a></li>
            <li><a href="classes.html">API</a></li>
            <li><a href="../faq.html">FAQ</a></li>
            <li><a href="../developers.html">贡献</a></li>
            <li class="divider"></li>
                <li><a href="http://scikit-learn.org/dev/documentation.html">Scikit-learn 0.18 (development)</a></li>
                <li><a href="http://scikit-learn.org/0.16/documentation.html">Scikit-learn 0.16</a></li>
				<li><a href="../_downloads/user_guide.pdf">PDF 文档</a></li>
              </ul>
            </div>
        </li>
            <li><a href="../auto_examples/index.html">例子</a></li>
            </ul>

            <div class="search_form">
                <div id="cse" style="width: 100%;"></div>
            </div>
        </div> <!-- end navbar --></div>
</div>


<!-- Github "fork me" ribbon -->
<a href="https://github.com/lzjqsdd/scikit-learn-doc-cn">
  <img class="fork-me"
       style="position: absolute; top: 0; right: 0; border: 0;"
       src="../_static/img/forkme.png"
       alt="Fork me on GitHub" />
</a>

<div class="content-wrapper">
    <div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
        <div class="rel">
    

  <!-- rellinks[1:] is an ugly hack to avoid link to module
  index -->
        <div class="rellink">
        <a href="../model_selection.html"
        accesskey="P">Previous
        <br/>
        <span class="smallrellink">
        3. Model sele...
        </span>
            <span class="hiddenrellink">
            3. Model selection and evaluation
            </span>
        </a>
        </div>

    <!-- Ad a link to the 'up' page -->
        <div class="spacer">
        &nbsp;
        </div>
        <div class="rellink">
        <a href="../model_selection.html">
        Up
        <br/>
        <span class="smallrellink">
        3. Model sele...
        </span>
            <span class="hiddenrellink">
            3. Model selection and evaluation
            </span>
            
        </a>
        </div>
    </div>
    
      <p class="doc-version">This documentation is for scikit-learn <strong>version 0.18</strong> &mdash; <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p>
    <p class="citing">If you use the software, please consider <a href="../about.html#citing-scikit-learn">citing scikit-learn</a>.</p>
    <ul>
<li><a class="reference internal" href="#">3.1. Cross-validation: 评估 estimator 的性能</a><ul>
<li><a class="reference internal" href="#computing-cross-validated-metrics">3.1.1. Computing cross-validated metrics 计算交叉验证指标</a><ul>
<li><a class="reference internal" href="#obtaining-predictions-by-cross-validation">3.1.1.1. Obtaining predictions by cross-validation 通过交叉验证获得预测</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cross-validation-iterators">3.1.2. Cross validation iterators 交叉验证迭代器</a><ul>
<li><a class="reference internal" href="#k-fold">3.1.2.1. K-fold</a></li>
<li><a class="reference internal" href="#stratified-k-fold-k-fold">3.1.2.2. Stratified k-fold 分层 k-fold</a></li>
<li><a class="reference internal" href="#label-k-fold-k-fold">3.1.2.3. Label k-fold 标签 k-fold</a></li>
<li><a class="reference internal" href="#leave-one-out-loo">3.1.2.4. Leave-One-Out - LOO 留一</a></li>
<li><a class="reference internal" href="#leave-p-out-lpo">3.1.2.5. Leave-P-Out - LPO</a></li>
<li><a class="reference internal" href="#leave-one-label-out-lolo">3.1.2.6. Leave-One-Label-Out - LOLO</a></li>
<li><a class="reference internal" href="#leave-p-label-out">3.1.2.7. Leave-P-Label-Out</a></li>
<li><a class="reference internal" href="#random-permutations-cross-validation-a-k-a-shuffle-split">3.1.2.8. Random permutations cross-validation a.k.a. Shuffle &amp; Split</a></li>
<li><a class="reference internal" href="#label-shuffle-split">3.1.2.9. Label-Shuffle-Split 标签随机划分</a></li>
<li><a class="reference internal" href="#predefined-fold-splits-validation-sets">3.1.2.10. Predefined Fold-Splits / Validation-Sets 预定义 交叉划分 / 验证集合</a></li>
<li><a class="reference internal" href="#see-also">3.1.2.11. See also 其他资料</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-note-on-shuffling">3.1.3. A note on shuffling 打乱顺序的说明</a></li>
<li><a class="reference internal" href="#cross-validation-and-model-selection">3.1.4. Cross validation and model selection 交叉验证和模型选择</a></li>
</ul>
</li>
</ul>

    </div>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" checked />
<label for="nav-trigger"></label>




      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="cross-validation-estimator">
<span id="cross-validation"></span><h1>3.1. Cross-validation: 评估 estimator 的性能<a class="headerlink" href="#cross-validation-estimator" title="Permalink to this headline">¶</a></h1>
<p>Learning the parameters of a prediction function and testing it on the
same data is a methodological mistake: a model that would just repeat
the labels of the samples that it has just seen would have a perfect
score but would fail to predict anything useful on yet-unseen data.
This situation is called <strong>overfitting</strong>.
To avoid it, it is common practice when performing
a (supervised) machine learning experiment
to hold out part of the available data as a <strong>test set</strong> <code class="docutils literal"><span class="pre">X_test,</span> <span class="pre">y_test</span></code>.
Note that the word &#8220;experiment&#8221; is not intended
to denote academic use only,
because even in commercial settings
machine learning usually starts out experimentally.
(学习一个预测函数的参数并且在相同的数据集上测试结果，在方法论上是不正确的：
一个仅给出测试用例标签的模型将会获得极高的分数，但是这个模型对没有见到过的数据，
则无法做出任何预测。这种情况称为 <strong>overfitting 过拟合</strong>。
为了避免这种情况，在（监督）学习实验中，通常会将一部分数据独立出来作为 <strong>测试集合</strong> <code class="docutils literal"><span class="pre">X_test,</span> <span class="pre">y_test</span></code>。
注意，“实验”不仅仅具有学术的意义，因为对于大部分商业系统，通常也是从实验性的系统开始的。)</p>
<p>In scikit-learn a random split into training and test sets
can be quickly computed with the <a class="reference internal" href="generated/sklearn.cross_validation.train_test_split.html#sklearn.cross_validation.train_test_split" title="sklearn.cross_validation.train_test_split"><code class="xref py py-func docutils literal"><span class="pre">train_test_split</span></code></a> helper function.
Let&#8217;s load the iris data set to fit a linear support vector machine on it  (
在 scikit-learn 中，可以使用辅助函数 <a class="reference internal" href="generated/sklearn.cross_validation.train_test_split.html#sklearn.cross_validation.train_test_split" title="sklearn.cross_validation.train_test_split"><code class="xref py py-func docutils literal"><span class="pre">train_test_split</span></code></a> 快速地将数据划分为训练集合与测试结合。
下面加载 iris 数据集并用它来拟合一个线性支持向量机):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">cross_validation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">svm</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">iris</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((150, 4), (150,))</span>
</pre></div>
</div>
<p>We can now quickly sample a training set while holding out 40% of the
data for testing (evaluating) our classifier  (我们可以快速的采样到一个训练集合同时保留 40% 的数据用于测试（评估）我们的分类器):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">cross_validation</span><span class="o">.</span><span class="n">train_test_split</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">y_train</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((90, 4), (90,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">y_test</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((60, 4), (60,))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>                           
<span class="go">0.96...</span>
</pre></div>
</div>
<p>When evaluating different settings (&#8220;hyperparameters&#8221;) for estimators,
such as the <code class="docutils literal"><span class="pre">C</span></code> setting that must be manually set for an SVM,
there is still a risk of overfitting <em>on the test set</em>
because the parameters can be tweaked until the estimator performs optimally.
This way, knowledge about the test set can &#8220;leak&#8221; into the model
and evaluation metrics no longer report on generalization performance.
To solve this problem, yet another part of the dataset can be held out
as a so-called &#8220;validation set&#8221;: training proceeds on the training set,
after which evaluation is done on the validation set,
and when the experiment seems to be successful,
final evaluation can be done on the test set.
(当评价估计器 (estimators) 不同的设置（“超参数”）时，比如 SVM 中必须人工设定 <code class="docutils literal"><span class="pre">C</span></code>, 这时候在**测试集合上**依然有过拟合的风险，
因为这个参数会被扭曲直到估计器获得最佳的性能。这时候，测试集合的内容会被“泄露”到模型中，评价指标不再能够反映出范化的性能。
为了解决这个问题，数据集中的另一部分数据被保留出来，称之为“验证集合”：在训训练集合上训练，之后再验证集合上评估，完成实验后，
最终在测试集合上进行评价。)</p>
<p>However, by partitioning the available data into three sets,
we drastically reduce the number of samples
which can be used for learning the model,
and the results can depend on a particular random choice for the pair of
(train, validation) sets.
(然而，将可用的数据分为三个部分后，可以用于模型训练的样例数量被大大降低了，而且结果会受到随机选择的（训练，验证）集合的影响。)</p>
<p>A solution to this problem is a procedure called
<a class="reference external" href="http://en.wikipedia.org/wiki/Cross-validation_(statistics)">cross-validation</a>
(CV for short).
A test set should still be held out for final evaluation,
but the validation set is no longer needed when doing CV.
In the basic approach, called <em>k</em>-fold CV,
the training set is split into <em>k</em> smaller sets
(other approaches are described below,
but generally follow the same principles).
The following procedure is followed for each of the <em>k</em> &#8220;folds&#8221;(一个用于解决这个问题的方法称为
<a class="reference external" href="http://en.wikipedia.org/wiki/Cross-validation_(statistics)">cross-validation</a>
（CV 是简称）。
测试数据集任然会保留出来用于最终的评价，但是验证集合在进行 CV 时不再需要。
基本的方法称之为 <em>k</em>-fold CV （k 折叠交叉验证），训练数据被分为 <em>k</em> 个小的集合（其他方法会在下面描述，主要原则基本相同）。
下面的步骤会在每个 <em>k</em> &#8220;folds&#8221; 上重复):</p>
<blockquote>
<div><ul class="simple">
<li>A model is trained using <img class="math" src="../_images/math/61e28425012ff04c501a81720cdd9f9b5afb962e.png" alt="k-1"/> of the folds as training data; (使用 <img class="math" src="../_images/math/61e28425012ff04c501a81720cdd9f9b5afb962e.png" alt="k-1"/> 个 folds 作为训练数据训练一个模型。)</li>
<li>the resulting model is validated on the remaining part of the data
(i.e., it is used as a test set to compute a performance measure
such as accuracy). (得到的模型会在剩下的数据上验证（比如：将会作为一个测试集合来衡量性能，如精确度）。</li>
</ul>
</div></blockquote>
<p>The performance measure reported by <em>k</em>-fold cross-validation
is then the average of the values computed in the loop.
This approach can be computationally expensive,
but does not waste too much data
(as it is the case when fixing an arbitrary test set),
which is a major advantage in problem such as inverse inference
where the number of samples is very small.
(由 <em>k</em>-fold 交叉验证得到性能指标是循环中各个值的平均值。这个方法的计算代价很高，但不会浪费很多的数据（这种情况下仅有一个固定的测试集合），
在一些问题如反向推断 (inverse inference) 中， 比较有优势。)</p>
<div class="section" id="computing-cross-validated-metrics">
<h2>3.1.1. Computing cross-validated metrics 计算交叉验证指标<a class="headerlink" href="#computing-cross-validated-metrics" title="Permalink to this headline">¶</a></h2>
<p>The simplest way to use cross-validation is to call the
<a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><code class="xref py py-func docutils literal"><span class="pre">cross_val_score</span></code></a> helper function on the estimator and the dataset.
(最简单的使用 cross-validation 的方式是在估计器和数据集上调用 <a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><code class="xref py py-func docutils literal"><span class="pre">cross_val_score</span></code></a> 的帮助函数。)</p>
<p>The following example demonstrates how to estimate the accuracy of a linear
kernel support vector machine on the iris dataset by splitting the data, fitting
a model and computing the score 5 consecutive times (with different splits each
time)(下面的例子演示了如何评估一个线性支持向量机在 iris 数据集上的精度，通过划分数据，可以连续5次,使用不同的划分方法
拟合并评分):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">cross_validation</span><span class="o">.</span><span class="n">cross_val_score</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">clf</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span>                                              
<span class="go">array([ 0.96...,  1.  ...,  0.96...,  0.96...,  1.        ])</span>
</pre></div>
</div>
<p>The mean score and the 95% confidence interval of the score estimate are hence
given by(平均分数和具有 95% 置信区间的分数估计给出如下):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Accuracy: </span><span class="si">%0.2f</span><span class="s2"> (+/- </span><span class="si">%0.2f</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">scores</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Accuracy: 0.98 (+/- 0.03)</span>
</pre></div>
</div>
<p>By default, the score computed at each CV iteration is the <code class="docutils literal"><span class="pre">score</span></code>
method of the estimator. It is possible to change this by using the
scoring parameter(默认地，每次 CV 迭代获得的分数由估计器的 <code class="docutils literal"><span class="pre">score</span></code> 函数计算得到。可以通过分数参数来改变计算方式如下):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">cross_validation</span><span class="o">.</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;f1_weighted&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span>                                              
<span class="go">array([ 0.96...,  1.  ...,  0.96...,  0.96...,  1.        ])</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="model_evaluation.html#scoring-parameter"><span class="std std-ref">The scoring parameter: defining model evaluation rules</span></a> for details.
In the case of the Iris dataset, the samples are balanced across target
classes hence the accuracy and the F1-score are almost equal.
(注意 <a class="reference internal" href="model_evaluation.html#scoring-parameter"><span class="std std-ref">The scoring parameter: defining model evaluation rules</span></a> 的细节。
在 Iris 数据集的情况下，各个分类的样例数目是比较均衡的，因而精度和 F1-scoree 基本相同。)</p>
<p>When the <code class="docutils literal"><span class="pre">cv</span></code> argument is an integer, <a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><code class="xref py py-func docutils literal"><span class="pre">cross_val_score</span></code></a> uses the
<a class="reference internal" href="generated/sklearn.cross_validation.KFold.html#sklearn.cross_validation.KFold" title="sklearn.cross_validation.KFold"><code class="xref py py-class docutils literal"><span class="pre">KFold</span></code></a> or <a class="reference internal" href="generated/sklearn.cross_validation.StratifiedKFold.html#sklearn.cross_validation.StratifiedKFold" title="sklearn.cross_validation.StratifiedKFold"><code class="xref py py-class docutils literal"><span class="pre">StratifiedKFold</span></code></a> strategies by default, the latter
being used if the estimator derives from <a class="reference internal" href="generated/sklearn.base.ClassifierMixin.html#sklearn.base.ClassifierMixin" title="sklearn.base.ClassifierMixin"><code class="xref py py-class docutils literal"><span class="pre">ClassifierMixin</span></code></a>.
(当 <code class="docutils literal"><span class="pre">cv</span></code> 参数是一个整数时，<a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><code class="xref py py-func docutils literal"><span class="pre">cross_val_score</span></code></a> 默认地使用 <a class="reference internal" href="generated/sklearn.cross_validation.KFold.html#sklearn.cross_validation.KFold" title="sklearn.cross_validation.KFold"><code class="xref py py-class docutils literal"><span class="pre">KFold</span></code></a> 或者 <a class="reference internal" href="generated/sklearn.cross_validation.StratifiedKFold.html#sklearn.cross_validation.StratifiedKFold" title="sklearn.cross_validation.StratifiedKFold"><code class="xref py py-class docutils literal"><span class="pre">StratifiedKFold</span></code></a> 策略，
后者会在估计器衍生自 <a class="reference internal" href="generated/sklearn.base.ClassifierMixin.html#sklearn.base.ClassifierMixin" title="sklearn.base.ClassifierMixin"><code class="xref py py-class docutils literal"><span class="pre">ClassifierMixin</span></code></a> 时使用。)</p>
<p>It is also possible to use other cross validation strategies by passing a cross
validation iterator instead, for instance(也可以通过传入一个交叉验证迭代器来使用其他的交叉验证策略，比如):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">cross_validation</span><span class="o">.</span><span class="n">ShuffleSplit</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">cross_validation</span><span class="o">.</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">cv</span><span class="p">)</span>
<span class="gp">... </span>                                                    
<span class="go">array([ 0.97...,  0.97...,  1.        ])</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Data transformation with held out data</p>
<p>Just as it is important to test a predictor on data held-out from
training, preprocessing (such as standardization, feature selection, etc.)
and similar <a class="reference internal" href="../data_transforms.html#data-transforms"><span class="std std-ref">data transformations</span></a> similarly should
be learnt from a training set and applied to held-out data for prediction(在保
留的数据上测试预测器时，预处理（比如标准化，特征选择等） <a class="reference internal" href="../data_transforms.html#data-transforms"><span class="std std-ref">data transformations</span></a>
也应该是和训练数据集相同的):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">preprocessing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">cross_validation</span><span class="o">.</span><span class="n">train_test_split</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_transformed</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_transformed</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test_transformed</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test_transformed</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>  
<span class="go">0.9333...</span>
</pre></div>
</div>
<p>A <a class="reference internal" href="generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal"><span class="pre">Pipeline</span></code></a> makes it easier to compose
estimators, providing this behavior under cross-validation(<a class="reference internal" href="generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal"><span class="pre">Pipeline</span></code></a>
使得组合估计器变得十分简单，在 cross-Validation 下使用如下):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="k">import</span> <span class="n">make_pipeline</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">StandardScaler</span><span class="p">(),</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cross_validation</span><span class="o">.</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">cv</span><span class="p">)</span>
<span class="gp">... </span>                                                
<span class="go">array([ 0.97...,  0.93...,  0.95...])</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="pipeline.html#combining-estimators"><span class="std std-ref">Pipeline and FeatureUnion: combining estimators</span></a>.</p>
</div>
<div class="section" id="obtaining-predictions-by-cross-validation">
<h3>3.1.1.1. Obtaining predictions by cross-validation 通过交叉验证获得预测<a class="headerlink" href="#obtaining-predictions-by-cross-validation" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="generated/sklearn.cross_validation.cross_val_predict.html#sklearn.cross_validation.cross_val_predict" title="sklearn.cross_validation.cross_val_predict"><code class="xref py py-func docutils literal"><span class="pre">cross_val_predict</span></code></a> has a similar interface to
<a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><code class="xref py py-func docutils literal"><span class="pre">cross_val_score</span></code></a>, but returns, for each element in the input, the
prediction that was obtained for that element when it was in the test set. Only
cross-validation strategies that assign all elements to a test set exactly once
can be used (otherwise, an exception is raised).(
除了返回结果不同，函数 <a class="reference internal" href="generated/sklearn.cross_validation.cross_val_predict.html#sklearn.cross_validation.cross_val_predict" title="sklearn.cross_validation.cross_val_predict"><code class="xref py py-func docutils literal"><span class="pre">cross_val_predict</span></code></a> 具有和 <a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><code class="xref py py-func docutils literal"><span class="pre">cross_val_score</span></code></a> 相同的接口，
对于每一个输入的元素，如果其在测试集合中，将会得到预测结果。交叉验证策略会将可用的元素提交到测试集合有且仅有一次（否则会抛出一个异常）。)</p>
<p>These prediction can then be used to evaluate the classifier(这些预测可以用于评价分类器的效果):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">predicted</span> <span class="o">=</span> <span class="n">cross_validation</span><span class="o">.</span><span class="n">cross_val_predict</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
<span class="gp">... </span>                                               <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">predicted</span><span class="p">)</span> 
<span class="go">0.966...</span>
</pre></div>
</div>
<p>Note that the result of this computation may be slightly different from those
obtained using <a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><code class="xref py py-func docutils literal"><span class="pre">cross_val_score</span></code></a> as the elements are grouped in different
ways.(注意，这个计算的结果和 <a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><code class="xref py py-func docutils literal"><span class="pre">cross_val_score</span></code></a> 有轻微的差别，因为后者用另一种方式组织元素。)</p>
<p>The available cross validation iterators are introduced in the following
section.(可用的交叉验证迭代器在下面的部分中。)</p>
<div class="topic">
<p class="topic-title first">Examples</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/model_selection/plot_roc_crossval.html#example-model-selection-plot-roc-crossval-py"><span class="std std-ref">Receiver Operating Characteristic (ROC) with cross validation</span></a>,</li>
<li><a class="reference internal" href="../auto_examples/feature_selection/plot_rfe_with_cross_validation.html#example-feature-selection-plot-rfe-with-cross-validation-py"><span class="std std-ref">Recursive feature elimination with cross-validation</span></a>,</li>
<li><a class="reference internal" href="../auto_examples/model_selection/grid_search_digits.html#example-model-selection-grid-search-digits-py"><span class="std std-ref">Parameter estimation using grid search with cross-validation</span></a>,</li>
<li><a class="reference internal" href="../auto_examples/model_selection/grid_search_text_feature_extraction.html#example-model-selection-grid-search-text-feature-extraction-py"><span class="std std-ref">Sample pipeline for text feature extraction and evaluation</span></a>,</li>
<li><a class="reference internal" href="../auto_examples/plot_cv_predict.html#example-plot-cv-predict-py"><span class="std std-ref">Plotting Cross-Validated Predictions</span></a>,</li>
</ul>
</div>
</div>
</div>
<div class="section" id="cross-validation-iterators">
<h2>3.1.2. Cross validation iterators 交叉验证迭代器<a class="headerlink" href="#cross-validation-iterators" title="Permalink to this headline">¶</a></h2>
<p>The following sections list utilities to generate indices
that can be used to generate dataset splits according to different cross
validation strategies.(接下来的部分列出了一些用于生成索引标号，用于在不同的交叉验证策略中生成数据划分的工具。)</p>
<div class="section" id="k-fold">
<h3>3.1.2.1. K-fold<a class="headerlink" href="#k-fold" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.cross_validation.KFold.html#sklearn.cross_validation.KFold" title="sklearn.cross_validation.KFold"><code class="xref py py-class docutils literal"><span class="pre">KFold</span></code></a> divides all the samples in <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/> groups of samples,
called folds (if <img class="math" src="../_images/math/1fc9e19dd71e5535697f6babb867aeb7562522dd.png" alt="k = n"/>, this is equivalent to the <em>Leave One
Out</em> strategy), of equal sizes (if possible). The prediction function is
learned using <img class="math" src="../_images/math/a9e4e9b9b08c8a427086d52289abb1934f901edb.png" alt="k - 1"/> folds, and the fold left out is used for test.
(<a class="reference internal" href="generated/sklearn.cross_validation.KFold.html#sklearn.cross_validation.KFold" title="sklearn.cross_validation.KFold"><code class="xref py py-class docutils literal"><span class="pre">KFold</span></code></a> 将所有的样例划分为 <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/> 个组，称为折叠 (fold) （如果 <img class="math" src="../_images/math/1fc9e19dd71e5535697f6babb867aeb7562522dd.png" alt="k = n"/>，
这等价于 <em>Leave One Out 留一</em> 策略），都具有相同的大小（如果可能）。预测函数学习时使用 <img class="math" src="../_images/math/a9e4e9b9b08c8a427086d52289abb1934f901edb.png" alt="k - 1"/>
个折叠中的数据，最后一个剩下的折叠会用于测试。)</p>
<p>Example of 2-fold cross-validation on a dataset with 4 samples(在 4 个样例的数据集上使用 2-fold 交叉验证的例子):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">KFold</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">kf</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">kf</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">))</span>
<span class="go">[2 3] [0 1]</span>
<span class="go">[0 1] [2 3]</span>
</pre></div>
</div>
<p>Each fold is constituted by two arrays: the first one is related to the
<em>training set</em>, and the second one to the <em>test set</em>.
(每个折叠由两个数组组成，第一个作为 <em>training set</em>，另一个作为 <em>test set</em>。)
Thus, one can create the training/test sets using numpy indexing(由此，可以通过使用 numpy 的索引创建训练/测试集合):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">train</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">test</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">train</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">test</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="stratified-k-fold-k-fold">
<h3>3.1.2.2. Stratified k-fold 分层 k-fold<a class="headerlink" href="#stratified-k-fold-k-fold" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.cross_validation.StratifiedKFold.html#sklearn.cross_validation.StratifiedKFold" title="sklearn.cross_validation.StratifiedKFold"><code class="xref py py-class docutils literal"><span class="pre">StratifiedKFold</span></code></a> is a variation of <em>k-fold</em> which returns <em>stratified</em>
folds: each set contains approximately the same percentage of samples of each
target class as the complete set.(<a class="reference internal" href="generated/sklearn.cross_validation.StratifiedKFold.html#sklearn.cross_validation.StratifiedKFold" title="sklearn.cross_validation.StratifiedKFold"><code class="xref py py-class docutils literal"><span class="pre">StratifiedKFold</span></code></a> 是 <em>k-fold</em> 的变种，会返回 <em>分层</em> 的折叠：每个小集合中，
各个类别的样例比例大致和完整数据集中相同。)</p>
<p>Example of stratified 3-fold cross-validation on a dataset with 10 samples from
two slightly unbalanced classes(在有10个样例的，有两个略不均衡类别的数据集上进行分层 3-fold 交叉验证的例子):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">StratifiedKFold</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skf</span> <span class="o">=</span> <span class="n">StratifiedKFold</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">skf</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">))</span>
<span class="go">[2 3 6 7 8 9] [0 1 4 5]</span>
<span class="go">[0 1 3 4 5 8 9] [2 6 7]</span>
<span class="go">[0 1 2 4 5 6 7] [3 8 9]</span>
</pre></div>
</div>
</div>
<div class="section" id="label-k-fold-k-fold">
<h3>3.1.2.3. Label k-fold 标签 k-fold<a class="headerlink" href="#label-k-fold-k-fold" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.cross_validation.LabelKFold.html#sklearn.cross_validation.LabelKFold" title="sklearn.cross_validation.LabelKFold"><code class="xref py py-class docutils literal"><span class="pre">LabelKFold</span></code></a> is a variation of <em>k-fold</em> which ensures that the same
label is not in both testing and training sets. This is necessary for example
if you obtained data from different subjects and you want to avoid over-fitting
(i.e., learning person specific features) by testing and training on different
subjects.(<a class="reference internal" href="generated/sklearn.cross_validation.LabelKFold.html#sklearn.cross_validation.LabelKFold" title="sklearn.cross_validation.LabelKFold"><code class="xref py py-class docutils literal"><span class="pre">LabelKFold</span></code></a> 也是一个 <em>k-fold</em> 的变种，他会保证相同的 label 不会同时属于测试和训练集合。
在有些情况下这是有必要的，比如你从不同的主题获取数据，而且在不同的主题上测试和训练（比如，学习个人的特殊特征）时你要避免过拟合。)</p>
<p>Imagine you have three subjects, each with an associated number from 1 to 3(设想你有三个主题，依次对应着 1 到 3):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">LabelKFold</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">lkf</span> <span class="o">=</span> <span class="n">LabelKFold</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">lkf</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">))</span>
<span class="go">[0 1 2 3 4 5] [6 7 8 9]</span>
<span class="go">[0 1 2 6 7 8 9] [3 4 5]</span>
<span class="go">[3 4 5 6 7 8 9] [0 1 2]</span>
</pre></div>
</div>
<p>Each subject is in a different testing fold, and the same subject is never in
both testing and training. Notice that the folds do not have exactly the same
size due to the imbalance in the data.(每一个主题在不同的测试折叠中，而且相同的主题不会
同时出现在测试训练的数据集中。注意，这些折叠并不含有相同的尺寸，因为数据是不均衡的。)</p>
</div>
<div class="section" id="leave-one-out-loo">
<h3>3.1.2.4. Leave-One-Out - LOO 留一<a class="headerlink" href="#leave-one-out-loo" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneOut.html#sklearn.cross_validation.LeaveOneOut" title="sklearn.cross_validation.LeaveOneOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneOut</span></code></a> (or LOO) is a simple cross-validation. Each learning
set is created by taking all the samples except one, the test set being
the sample left out. Thus, for <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> samples, we have <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> different
training sets and <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> different tests set. This cross-validation
procedure does not waste much data as only one sample is removed from the
training set(<a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneOut.html#sklearn.cross_validation.LeaveOneOut" title="sklearn.cross_validation.LeaveOneOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneOut</span></code></a> (或者 LOO) 是一个简单的交叉验证。每个学习的集合由一个单独的训练样例组成，测试
集合是最后一个剩余的训练样例。因此，对于 <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> 个样例，我们有 <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> 个不同的训练集合和 <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/>
个不同的测试集合。因为只有一个训练样例被保留出来，因而交叉验证不会浪费过多的数据):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">LeaveOneOut</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">loo</span> <span class="o">=</span> <span class="n">LeaveOneOut</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">loo</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">))</span>
<span class="go">[1 2 3] [0]</span>
<span class="go">[0 2 3] [1]</span>
<span class="go">[0 1 3] [2]</span>
<span class="go">[0 1 2] [3]</span>
</pre></div>
</div>
<p>Potential users of LOO for model selection should weigh a few known caveats.
When compared with <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/>-fold cross validation, one builds <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> models
from <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> samples instead of <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/> models, where <img class="math" src="../_images/math/74ee316bb8dee156028f664712dc8a7a5041c3e9.png" alt="n &gt; k"/>.
Moreover, each is trained on <img class="math" src="../_images/math/72d8a65b17ed7725b7ea4889ade867111639176d.png" alt="n - 1"/> samples rather than
<img class="math" src="../_images/math/ad3df7121ca6aa5ab9129118de90ec1f04f4e31a.png" alt="(k-1)n / k"/>. In both ways, assuming <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/> is not too large
and <img class="math" src="../_images/math/0c3095fa818c49399a1b1160ae1f756e94acb6e9.png" alt="k &lt; n"/>, LOO is more computationally expensive than <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/>-fold
cross validation.(使用 LOO 进行模型选择时，应当注意一些已知的警告。和 <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/>-fold 交叉验证比较，
one 会从 <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> 个样例中构建 <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/>
个模型，而当 <img class="math" src="../_images/math/74ee316bb8dee156028f664712dc8a7a5041c3e9.png" alt="n &gt; k"/> 时 <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/>-fold 仅会构建 <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/> 个模型。
更重要的是，一个在 <img class="math" src="../_images/math/72d8a65b17ed7725b7ea4889ade867111639176d.png" alt="n - 1"/> 个样例上训练，而另一个在 <img class="math" src="../_images/math/ad3df7121ca6aa5ab9129118de90ec1f04f4e31a.png" alt="(k-1)n / k"/> 个样例上训练。
这两种方式，假设 <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/> 不会很大，而且 <img class="math" src="../_images/math/0c3095fa818c49399a1b1160ae1f756e94acb6e9.png" alt="k &lt; n"/>， LOO 的计算复杂度比 <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/>-fold 更高。)</p>
<p>In terms of accuracy, LOO often results in high variance as an estimator for the
test error. Intuitively, since <img class="math" src="../_images/math/72d8a65b17ed7725b7ea4889ade867111639176d.png" alt="n - 1"/> of
the <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> samples are used to build each model, models constructed from
folds are virtually identical to each other and to the model built from the
entire training set.(在精确度方面，LOO 经常会得到一个测试误差的方差比较高的估计器。
直观的，由于 <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> 个样例中的 <img class="math" src="../_images/math/72d8a65b17ed7725b7ea4889ade867111639176d.png" alt="n - 1"/> 个都用于训练，
构建模型的 folds 和用全部数据类构建模型是比较相似的。)</p>
<p>However, if the learning curve is steep for the training size in question,
then 5- or 10- fold cross validation can overestimate the generalization error.
(然而，如果问题中的学习曲线 (learning curve) 相对于训练数据集大小的曲线比较陡峭，那么 5- 或者 10- 的折叠验证会导致泛化误差过拟合。)</p>
<p>As a general rule, most authors, and empirical evidence, suggest that 5- or 10-
fold cross validation should be preferred to LOO.(一般的规则，大部分作者，
和经验证据都表明 5- 或者 10- 的折叠交叉验证要好于 LOO。)</p>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.faqs.org/faqs/ai-faq/neural-nets/part3/section-12.html">http://www.faqs.org/faqs/ai-faq/neural-nets/part3/section-12.html</a></li>
<li>T. Hastie, R. Tibshirani, J. Friedman,  <a class="reference external" href="http://www-stat.stanford.edu/~tibs/ElemStatLearn">The Elements of Statistical Learning</a>, Springer 2009</li>
<li>L. Breiman, P. Spector <a class="reference external" href="http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/197.pdf">Submodel selection and evaluation in regression: The X-random case</a>, International Statistical Review 1992</li>
<li>R. Kohavi, <a class="reference external" href="http://www.cs.iastate.edu/~jtian/cs573/Papers/Kohavi-IJCAI-95.pdf">A Study of Cross-Validation and Bootstrap for Accuracy Estimation and Model Selection</a>, Intl. Jnt. Conf. AI</li>
<li>R. Bharat Rao, G. Fung, R. Rosales, <a class="reference external" href="http://www.siam.org/proceedings/datamining/2008/dm08_54_Rao.pdf">On the Dangers of Cross-Validation. An Experimental Evaluation</a>, SIAM 2008</li>
<li>G. James, D. Witten, T. Hastie, R Tibshirani, <a class="reference external" href="http://www-bcf.usc.edu/~gareth/ISL">An Introduction to
Statistical Learning</a>, Springer 2013</li>
</ul>
</div>
</div>
<div class="section" id="leave-p-out-lpo">
<h3>3.1.2.5. Leave-P-Out - LPO<a class="headerlink" href="#leave-p-out-lpo" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.cross_validation.LeavePOut.html#sklearn.cross_validation.LeavePOut" title="sklearn.cross_validation.LeavePOut"><code class="xref py py-class docutils literal"><span class="pre">LeavePOut</span></code></a> is very similar to <a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneOut.html#sklearn.cross_validation.LeaveOneOut" title="sklearn.cross_validation.LeaveOneOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneOut</span></code></a> as it creates all
the possible training/test sets by removing <img class="math" src="../_images/math/27d463da4622be5b3ef1d4176ced7d7a323c6425.png" alt="p"/> samples from the complete
set. For <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> samples, this produces <img class="math" src="../_images/math/db0633044e8b47d65250ffea6683c3aa3dd2a3c6.png" alt="{n \choose p}"/> train-test
pairs. Unlike <a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneOut.html#sklearn.cross_validation.LeaveOneOut" title="sklearn.cross_validation.LeaveOneOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneOut</span></code></a> and <a class="reference internal" href="generated/sklearn.cross_validation.KFold.html#sklearn.cross_validation.KFold" title="sklearn.cross_validation.KFold"><code class="xref py py-class docutils literal"><span class="pre">KFold</span></code></a>, the test sets will
overlap for <img class="math" src="../_images/math/1d718544ce7f48c349cbefc3be3cb4afdf451e12.png" alt="p &gt; 1"/>.(<a class="reference internal" href="generated/sklearn.cross_validation.LeavePOut.html#sklearn.cross_validation.LeavePOut" title="sklearn.cross_validation.LeavePOut"><code class="xref py py-class docutils literal"><span class="pre">LeavePOut</span></code></a> 和 <a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneOut.html#sklearn.cross_validation.LeaveOneOut" title="sklearn.cross_validation.LeaveOneOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneOut</span></code></a> 非常相似，其通过从完整的集合中移动 <img class="math" src="../_images/math/27d463da4622be5b3ef1d4176ced7d7a323c6425.png" alt="p"/> 个样例
创建了所有可能的训练/测试集合。对于 <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> 个样例，这会产生 <img class="math" src="../_images/math/db0633044e8b47d65250ffea6683c3aa3dd2a3c6.png" alt="{n \choose p}"/> 个训练-测试对。
不同于 <a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneOut.html#sklearn.cross_validation.LeaveOneOut" title="sklearn.cross_validation.LeaveOneOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneOut</span></code></a> 和 <a class="reference internal" href="generated/sklearn.cross_validation.KFold.html#sklearn.cross_validation.KFold" title="sklearn.cross_validation.KFold"><code class="xref py py-class docutils literal"><span class="pre">KFold</span></code></a>，当 <img class="math" src="../_images/math/1d718544ce7f48c349cbefc3be3cb4afdf451e12.png" alt="p &gt; 1"/> 时，测试集合会重叠。)</p>
<p>Example of Leave-2-Out on a dataset with 4 samples(在有 4 个样例的数据集上使用 Leave-2-Out 的例子):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">LeavePOut</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">lpo</span> <span class="o">=</span> <span class="n">LeavePOut</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">lpo</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">))</span>
<span class="go">[2 3] [0 1]</span>
<span class="go">[1 3] [0 2]</span>
<span class="go">[1 2] [0 3]</span>
<span class="go">[0 3] [1 2]</span>
<span class="go">[0 2] [1 3]</span>
<span class="go">[0 1] [2 3]</span>
</pre></div>
</div>
</div>
<div class="section" id="leave-one-label-out-lolo">
<h3>3.1.2.6. Leave-One-Label-Out - LOLO<a class="headerlink" href="#leave-one-label-out-lolo" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneLabelOut.html#sklearn.cross_validation.LeaveOneLabelOut" title="sklearn.cross_validation.LeaveOneLabelOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneLabelOut</span></code></a> (LOLO) is a cross-validation scheme which holds out
the samples according to a third-party provided array of integer labels. This
label information can be used to encode arbitrary domain specific pre-defined
cross-validation folds.(<a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneLabelOut.html#sklearn.cross_validation.LeaveOneLabelOut" title="sklearn.cross_validation.LeaveOneLabelOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneLabelOut</span></code></a> (LOLO) 是一个交叉验证的方法，通过第三方提供的一个整数标签数组来
保留样例。这个标签信息可以用于编码任意领域的特殊预定义交叉验证折叠。)</p>
<p>Each training set is thus constituted by all the samples except the ones
related to a specific label.(每一个训练集合由除去某个特别标签之外的所有其他样例组成。)</p>
<p>For example, in the cases of multiple experiments, <em>LOLO</em> can be used to
create a cross-validation based on the different experiments: we create
a training set using the samples of all the experiments except one(例如，在多次试验中，<em>LOLO</em> 可以给
不同的实验创建特定的交叉验证：我们创建一个训练集合使用除去某个实验之外所有实验的样例):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">LeaveOneLabelOut</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lolo</span> <span class="o">=</span> <span class="n">LeaveOneLabelOut</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">lolo</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">))</span>
<span class="go">[2 3] [0 1]</span>
<span class="go">[0 1] [2 3]</span>
</pre></div>
</div>
<p>Another common application is to use time information: for instance the
labels could be the year of collection of the samples and thus allow
for cross-validation against time-based splits.(另一种通常的使用场景是基于时间信息：
比如按照年份采样的集合，通过基于时间的划分来进行交叉验证。)</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Contrary to <a class="reference internal" href="generated/sklearn.cross_validation.StratifiedKFold.html#sklearn.cross_validation.StratifiedKFold" title="sklearn.cross_validation.StratifiedKFold"><code class="xref py py-class docutils literal"><span class="pre">StratifiedKFold</span></code></a> , ** the <code class="docutils literal"><span class="pre">labels</span></code> of
<a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneLabelOut.html#sklearn.cross_validation.LeaveOneLabelOut" title="sklearn.cross_validation.LeaveOneLabelOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneLabelOut</span></code></a> should not encode the target class to predict ** :
the goal of <a class="reference internal" href="generated/sklearn.cross_validation.StratifiedKFold.html#sklearn.cross_validation.StratifiedKFold" title="sklearn.cross_validation.StratifiedKFold"><code class="xref py py-class docutils literal"><span class="pre">StratifiedKFold</span></code></a> is to rebalance dataset classes across
the train / test split to ensure that the train and test folds have
approximately the same percentage of samples of each class while
<a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneLabelOut.html#sklearn.cross_validation.LeaveOneLabelOut" title="sklearn.cross_validation.LeaveOneLabelOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneLabelOut</span></code></a> will do the opposite by ensuring that the samples
of the train and test fold will not share the same label value.(和 <a class="reference internal" href="generated/sklearn.cross_validation.StratifiedKFold.html#sklearn.cross_validation.StratifiedKFold" title="sklearn.cross_validation.StratifiedKFold"><code class="xref py py-class docutils literal"><span class="pre">StratifiedKFold</span></code></a> 不同，
** <a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneLabelOut.html#sklearn.cross_validation.LeaveOneLabelOut" title="sklearn.cross_validation.LeaveOneLabelOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneLabelOut</span></code></a> 的标签不应该使用用于预测的类型信息来进行编码 ** ：
<a class="reference internal" href="generated/sklearn.cross_validation.StratifiedKFold.html#sklearn.cross_validation.StratifiedKFold" title="sklearn.cross_validation.StratifiedKFold"><code class="xref py py-class docutils literal"><span class="pre">StratifiedKFold</span></code></a> 的目标是对训练/测试集合中的数据类型进行均衡化，保证训练和测试集合中样例的类型比例比较接近，
而 <a class="reference internal" href="generated/sklearn.cross_validation.LeaveOneLabelOut.html#sklearn.cross_validation.LeaveOneLabelOut" title="sklearn.cross_validation.LeaveOneLabelOut"><code class="xref py py-class docutils literal"><span class="pre">LeaveOneLabelOut</span></code></a> 是做相反的事，即保证训练和测试集合不会共享相同的标签数值。)</p>
</div>
</div>
<div class="section" id="leave-p-label-out">
<h3>3.1.2.7. Leave-P-Label-Out<a class="headerlink" href="#leave-p-label-out" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.cross_validation.LeavePLabelOut.html#sklearn.cross_validation.LeavePLabelOut" title="sklearn.cross_validation.LeavePLabelOut"><code class="xref py py-class docutils literal"><span class="pre">LeavePLabelOut</span></code></a> is similar as <em>Leave-One-Label-Out</em>, but removes
samples related to <img class="math" src="../_images/math/9dcbbef8e0f76051d388013b90a95bec3069e484.png" alt="P"/> labels for each training/test set.(<a class="reference internal" href="generated/sklearn.cross_validation.LeavePLabelOut.html#sklearn.cross_validation.LeavePLabelOut" title="sklearn.cross_validation.LeavePLabelOut"><code class="xref py py-class docutils literal"><span class="pre">LeavePLabelOut</span></code></a>
和 <em>Leave-One-Label-Out</em> 类似，但在每个训练/测试集合对中会保留 <img class="math" src="../_images/math/9dcbbef8e0f76051d388013b90a95bec3069e484.png" alt="P"/> 个标签的数据作为验证集。)</p>
<p>Example of Leave-2-Label Out:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">LeavePLabelOut</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lplo</span> <span class="o">=</span> <span class="n">LeavePLabelOut</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">lplo</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">))</span>
<span class="go">[4 5] [0 1 2 3]</span>
<span class="go">[2 3] [0 1 4 5]</span>
<span class="go">[0 1] [2 3 4 5]</span>
</pre></div>
</div>
</div>
<div class="section" id="random-permutations-cross-validation-a-k-a-shuffle-split">
<span id="shufflesplit"></span><h3>3.1.2.8. Random permutations cross-validation a.k.a. Shuffle &amp; Split<a class="headerlink" href="#random-permutations-cross-validation-a-k-a-shuffle-split" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.cross_validation.ShuffleSplit.html#sklearn.cross_validation.ShuffleSplit" title="sklearn.cross_validation.ShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">ShuffleSplit</span></code></a> iterator will generate a user defined number of
independent train / test dataset splits. Samples are first shuffled and
then split into a pair of train and test sets.(<a class="reference internal" href="generated/sklearn.cross_validation.ShuffleSplit.html#sklearn.cross_validation.ShuffleSplit" title="sklearn.cross_validation.ShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">ShuffleSplit</span></code></a> 迭代器
将会生成一个用户给定数量的独立的训练/测试数据划分。样例首先被打散然后划分为一对训练测试集合。)</p>
<p>It is possible to control the randomness for reproducibility of the
results by explicitly seeding the <code class="docutils literal"><span class="pre">random_state</span></code> pseudo random number
generator. (可以通过设定明确的 <code class="docutils literal"><span class="pre">random_state</span></code>，使得伪随机生成器的结果可以重复。)</p>
<p>Here is a usage example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ss</span> <span class="o">=</span> <span class="n">cross_validation</span><span class="o">.</span><span class="n">ShuffleSplit</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">train_index</span><span class="p">,</span> <span class="n">test_index</span> <span class="ow">in</span> <span class="n">ss</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">train_index</span><span class="p">,</span> <span class="n">test_index</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">[1 3 4] [2 0]</span>
<span class="go">[1 4 3] [0 2]</span>
<span class="go">[4 0 2] [1 3]</span>
</pre></div>
</div>
<p><a class="reference internal" href="generated/sklearn.cross_validation.ShuffleSplit.html#sklearn.cross_validation.ShuffleSplit" title="sklearn.cross_validation.ShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">ShuffleSplit</span></code></a> is thus a good alternative to <a class="reference internal" href="generated/sklearn.cross_validation.KFold.html#sklearn.cross_validation.KFold" title="sklearn.cross_validation.KFold"><code class="xref py py-class docutils literal"><span class="pre">KFold</span></code></a> cross
validation that allows a finer control on the number of iterations and
the proportion of samples in on each side of the train / test split.
(<a class="reference internal" href="generated/sklearn.cross_validation.ShuffleSplit.html#sklearn.cross_validation.ShuffleSplit" title="sklearn.cross_validation.ShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">ShuffleSplit</span></code></a> 可以替代 <a class="reference internal" href="generated/sklearn.cross_validation.KFold.html#sklearn.cross_validation.KFold" title="sklearn.cross_validation.KFold"><code class="xref py py-class docutils literal"><span class="pre">KFold</span></code></a> 交叉验证，因为其提供了细致的训练 / 测试划分的
数量和样例所占的比例等的控制。)</p>
</div>
<div class="section" id="label-shuffle-split">
<h3>3.1.2.9. Label-Shuffle-Split 标签随机划分<a class="headerlink" href="#label-shuffle-split" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.cross_validation.LabelShuffleSplit.html#sklearn.cross_validation.LabelShuffleSplit" title="sklearn.cross_validation.LabelShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">LabelShuffleSplit</span></code></a> iterator behaves as a combination of
<a class="reference internal" href="generated/sklearn.cross_validation.ShuffleSplit.html#sklearn.cross_validation.ShuffleSplit" title="sklearn.cross_validation.ShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">ShuffleSplit</span></code></a> and <code class="xref py py-class docutils literal"><span class="pre">LeavePLabelsOut</span></code>, and generates a
sequence of randomized partitions in which a subset of labels are held
out for each split. (<a class="reference internal" href="generated/sklearn.cross_validation.LabelShuffleSplit.html#sklearn.cross_validation.LabelShuffleSplit" title="sklearn.cross_validation.LabelShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">LabelShuffleSplit</span></code></a> 迭代器是 <a class="reference internal" href="generated/sklearn.cross_validation.ShuffleSplit.html#sklearn.cross_validation.ShuffleSplit" title="sklearn.cross_validation.ShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">ShuffleSplit</span></code></a> 和 <code class="xref py py-class docutils literal"><span class="pre">LeavePLabelsOut</span></code>
的组合，他生成一个随机划分的序列，将同一标签的元素分散到各个划分中。)</p>
<p>Here is a usage example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="n">LabelShuffleSplit</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">slo</span> <span class="o">=</span> <span class="n">LabelShuffleSplit</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">slo</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">[0 1 2 3] [4 5 6 7]</span>
<span class="go">[2 3 6 7] [0 1 4 5]</span>
<span class="go">[2 3 4 5] [0 1 6 7]</span>
<span class="go">[4 5 6 7] [0 1 2 3]</span>
</pre></div>
</div>
<p>This class is useful when the behavior of <code class="xref py py-class docutils literal"><span class="pre">LeavePLabelsOut</span></code> is
desired, but the number of labels is large enough that generating all
possible partitions with <img class="math" src="../_images/math/9dcbbef8e0f76051d388013b90a95bec3069e484.png" alt="P"/> labels withheld would be prohibitively
expensive.  In such a scenario, <a class="reference internal" href="generated/sklearn.cross_validation.LabelShuffleSplit.html#sklearn.cross_validation.LabelShuffleSplit" title="sklearn.cross_validation.LabelShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">LabelShuffleSplit</span></code></a> provides
a random sample (with replacement) of the train / test splits
generated by <code class="xref py py-class docutils literal"><span class="pre">LeavePLabelsOut</span></code>.(当需要 <code class="xref py py-class docutils literal"><span class="pre">LeavePLabelsOut</span></code> 的操作时，class 信息是必要的，
但是当需要为所有可能的 P labels 保留划分的 labels 数量会很大，保存会有很大代价。在这种情况下，
<a class="reference internal" href="generated/sklearn.cross_validation.LabelShuffleSplit.html#sklearn.cross_validation.LabelShuffleSplit" title="sklearn.cross_validation.LabelShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">LabelShuffleSplit</span></code></a> 通过 <code class="xref py py-class docutils literal"><span class="pre">LeavePLabelsOut</span></code>
提供了一个随机（可重复）的训练 / 测试划分采样。)</p>
</div>
<div class="section" id="predefined-fold-splits-validation-sets">
<h3>3.1.2.10. Predefined Fold-Splits / Validation-Sets 预定义 交叉划分 / 验证集合<a class="headerlink" href="#predefined-fold-splits-validation-sets" title="Permalink to this headline">¶</a></h3>
<p>For some datasets, a pre-defined split of the data into training- and
validation fold or into several cross-validation folds already
exists. Using <a class="reference internal" href="generated/sklearn.cross_validation.PredefinedSplit.html#sklearn.cross_validation.PredefinedSplit" title="sklearn.cross_validation.PredefinedSplit"><code class="xref py py-class docutils literal"><span class="pre">PredefinedSplit</span></code></a> it is possible to use these folds
e.g. when searching for hyperparameters.(对一些数据集，一个预定义的，将数据划分为训练和验证集合或者划分为几个交叉验证集合的划分已经存在。
可以使用 <a class="reference internal" href="generated/sklearn.cross_validation.PredefinedSplit.html#sklearn.cross_validation.PredefinedSplit" title="sklearn.cross_validation.PredefinedSplit"><code class="xref py py-class docutils literal"><span class="pre">PredefinedSplit</span></code></a> 来使用这些集合来搜索超参数。)</p>
<p>For example, when using a validation set, set the <code class="docutils literal"><span class="pre">test_fold</span></code> to 0 for all
samples that are part of the validation set, and to -1 for all other samples.
(比如，当使用验证集合时，设置所有验证集合中的样例的 <code class="docutils literal"><span class="pre">test_fold</span></code> 为0，而将其他样例设置为 -1.)</p>
</div>
<div class="section" id="see-also">
<h3>3.1.2.11. See also 其他资料<a class="headerlink" href="#see-also" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.cross_validation.StratifiedShuffleSplit.html#sklearn.cross_validation.StratifiedShuffleSplit" title="sklearn.cross_validation.StratifiedShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">StratifiedShuffleSplit</span></code></a> is a variation of <em>ShuffleSplit</em>, which returns
stratified splits, <em>i.e</em> which creates splits by preserving the same
percentage for each target class as in the complete set.(<a class="reference internal" href="generated/sklearn.cross_validation.StratifiedShuffleSplit.html#sklearn.cross_validation.StratifiedShuffleSplit" title="sklearn.cross_validation.StratifiedShuffleSplit"><code class="xref py py-class docutils literal"><span class="pre">StratifiedShuffleSplit</span></code></a> 是 <em>ShuffleSplit</em> 的一个变种，会返回直接的划分，比如：
创建一个划分，但是划分中每个类的比例和完整数据集中的相同。)</p>
</div>
</div>
<div class="section" id="a-note-on-shuffling">
<h2>3.1.3. A note on shuffling 打乱顺序的说明<a class="headerlink" href="#a-note-on-shuffling" title="Permalink to this headline">¶</a></h2>
<p>If the data ordering is not arbitrary (e.g. samples with the same label are
contiguous), shuffling it first may be essential to get a meaningful cross-
validation result. However, the opposite may be true if the samples are not
independently and identically distributed. For example, if samples correspond
to news articles, and are ordered by their time of publication, then shuffling
the data will likely lead to a model that is overfit and an inflated validation
score: it will be tested on samples that are artificially similar (close in
time) to training samples.(如果数据的顺序不是任意的（比如说，相同标签的样例连续出现），为了获得有意义的交叉验证结果，首先对其进行
打散是很有必要的。然而，当样例不是独立同分布时打散则是不可行的。例如：样例是相关的文章，以他们发表的时间
进行排序，这时候如果对数据进行打散，将会导致模型过拟合，得到一个过高的验证分数：因为验证样例更加相似（在时间上更接近）
于训练数据。)</p>
<p>Some cross validation iterators, such as <a class="reference internal" href="generated/sklearn.cross_validation.KFold.html#sklearn.cross_validation.KFold" title="sklearn.cross_validation.KFold"><code class="xref py py-class docutils literal"><span class="pre">KFold</span></code></a>, have an inbuilt option
to shuffle the data indices before splitting them. Note that(一些交叉验证迭代器，
比如 <a class="reference internal" href="generated/sklearn.cross_validation.KFold.html#sklearn.cross_validation.KFold" title="sklearn.cross_validation.KFold"><code class="xref py py-class docutils literal"><span class="pre">KFold</span></code></a>，有一个内建的在划分数据前进行数据索引打散的选项。注意):</p>
<ul class="simple">
<li>This consumes less memory than shuffling the data directly. (这种方式仅需要很少的内存就可以打散数据。)</li>
<li>By default no shuffling occurs, including for the (stratified) K fold cross-
validation performed by specifying <code class="docutils literal"><span class="pre">cv=some_integer</span></code> to
<a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><code class="xref py py-func docutils literal"><span class="pre">cross_val_score</span></code></a>, grid search, etc. Keep in mind that
<a class="reference internal" href="generated/sklearn.cross_validation.train_test_split.html#sklearn.cross_validation.train_test_split" title="sklearn.cross_validation.train_test_split"><code class="xref py py-func docutils literal"><span class="pre">train_test_split</span></code></a> still returns a random split.
(默认不会进行打散，包括设置 <code class="docutils literal"><span class="pre">cv=some_integer</span></code> （直接）k 折叠交叉验证的 <a class="reference internal" href="generated/sklearn.cross_validation.cross_val_score.html#sklearn.cross_validation.cross_val_score" title="sklearn.cross_validation.cross_val_score"><code class="xref py py-func docutils literal"><span class="pre">cross_val_score</span></code></a> ，
表格搜索等。注意 <a class="reference internal" href="generated/sklearn.cross_validation.train_test_split.html#sklearn.cross_validation.train_test_split" title="sklearn.cross_validation.train_test_split"><code class="xref py py-func docutils literal"><span class="pre">train_test_split</span></code></a> 会返回一个随机的划分。)</li>
<li>The <code class="docutils literal"><span class="pre">random_state</span></code> parameter defaults to <code class="docutils literal"><span class="pre">None</span></code>, meaning that the
shuffling will be different every time <code class="docutils literal"><span class="pre">KFold(...,</span> <span class="pre">shuffle=True)</span></code> is
iterated. However, <code class="docutils literal"><span class="pre">GridSearchCV</span></code> will use the same shuffling for each set
of parameters validated by a single call to its <code class="docutils literal"><span class="pre">fit</span></code> method.
(参数 <code class="docutils literal"><span class="pre">random_state</span></code> 默认设置为 <code class="docutils literal"><span class="pre">None</span></code>，这意为着每次进行 <code class="docutils literal"><span class="pre">KFold(...,</span> <span class="pre">shuffle=True)</span></code> 时，打散都是不同的。
然而，<code class="docutils literal"><span class="pre">GridSearchCV</span></code> 通过调用 <code class="docutils literal"><span class="pre">fit</span></code> 方法验证时，将会使用相同的打散来训练每一组参数。)</li>
<li>To ensure results are repeatable (<em>on the same platform</em>), use a fixed value
for <code class="docutils literal"><span class="pre">random_state</span></code>. (为了保证结果的可重复性（<em>在相同的平台上</em>），应该给 <code class="docutils literal"><span class="pre">random_state</span></code> 设定一个固定的值。)</li>
</ul>
</div>
<div class="section" id="cross-validation-and-model-selection">
<h2>3.1.4. Cross validation and model selection 交叉验证和模型选择<a class="headerlink" href="#cross-validation-and-model-selection" title="Permalink to this headline">¶</a></h2>
<p>Cross validation iterators can also be used to directly perform model
selection using Grid Search for the optimal hyperparameters of the
model. This is the topic if the next section: <a class="reference internal" href="grid_search.html#grid-search"><span class="std std-ref">Grid Search: Searching for estimator parameters</span></a>.
(交叉验证迭代器可以通过网格搜索得到最优的模型超参数，从而直接用于模型的选择。
这是另一部分 section: <a class="reference internal" href="grid_search.html#grid-search"><span class="std std-ref">Grid Search: Searching for estimator parameters</span></a> 的主要内容。)</p>
</div>
</div>


          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer">
        &copy; 2010 - 2014, scikit-learn developers (BSD License).
      <a href="../_sources/modules/cross_validation.txt" rel="nofollow">Show this page source</a>
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="../model_selection.html">Previous
      </a>
    </div>
    
     </div>

    
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-22606712-2']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    

    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
    <script type="text/javascript"> google.load('search', '1',
        {language : 'en'}); google.setOnLoadCallback(function() {
            var customSearchControl = new
            google.search.CustomSearchControl('016639176250731907682:tjtqbvtvij0');
            customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
            var options = new google.search.DrawOptions();
            options.setAutoComplete(true);
            customSearchControl.draw('cse', options); }, true);
    </script>
  </body>
</html>