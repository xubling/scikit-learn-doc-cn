
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
  
    <title>4.3. 数据预处理 &#8212; scikit-learn 0.18 documentation</title>
  <!-- htmltitle is before nature.css - we use this hack to load bootstrap first -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../_static/css/bootstrap.min.css" media="screen" />
  <link rel="stylesheet" href="../_static/css/bootstrap-responsive.css"/>

    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.18',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="scikit-learn 0.18 documentation" href="../index.html" />
    <link rel="up" title="4. Dataset transformations" href="../data_transforms.html" />
    <link rel="next" title="4.4. Unsupervised dimensionality reduction" href="unsupervised_reduction.html" />
    <link rel="prev" title="4.2. 特征提取" href="feature_extraction.html" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="../_static/js/bootstrap.min.js" type="text/javascript"></script>
  <link rel="canonical" href="http://scikit-learn.org/stable/modules/preprocessing.html" />

  <script type="text/javascript">
    $("div.buttonNext, div.buttonPrevious").hover(
       function () {
           $(this).css('background-color', '#FF9C34');
       },
       function () {
           $(this).css('background-color', '#A7D6E2');
       }
    );
  </script>

  </head>
  <body role="document">

<div class="header-wrapper">
    <div class="header">
        <p class="logo"><a href="../index.html">
            <img src="../_static/scikit-learn-logo-small.png" alt="Logo"/>
        </a>
        </p><div class="navbar">
            <ul>
                <li><a href="../index.html">主页</a></li>
                <li><a href="../install.html">安装</a></li>
                <li class="btn-li"><div class="btn-group">
              <a href="../documentation.html">文档</a>
              <a class="btn dropdown-toggle" data-toggle="dropdown">
                 <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
            <li class="link-title">Scikit-learn 0.17 (stable)</li>
            <li><a href="../tutorial/index.html">入门指南</a></li>
            <li><a href="../user_guide.html">使用手册</a></li>
            <li><a href="classes.html">API</a></li>
            <li><a href="../faq.html">FAQ</a></li>
            <li><a href="../developers.html">贡献</a></li>
            <li class="divider"></li>
                <li><a href="http://scikit-learn.org/dev/documentation.html">Scikit-learn 0.18 (development)</a></li>
                <li><a href="http://scikit-learn.org/0.16/documentation.html">Scikit-learn 0.16</a></li>
				<li><a href="../_downloads/user_guide.pdf">PDF 文档</a></li>
              </ul>
            </div>
        </li>
            <li><a href="../auto_examples/index.html">例子</a></li>
            </ul>

            <div class="search_form">
                <div id="cse" style="width: 100%;"></div>
            </div>
        </div> <!-- end navbar --></div>
</div>


<!-- Github "fork me" ribbon -->
<a href="https://github.com/lzjqsdd/scikit-learn-doc-cn">
  <img class="fork-me"
       style="position: absolute; top: 0; right: 0; border: 0;"
       src="../_static/img/forkme.png"
       alt="Fork me on GitHub" />
</a>

<div class="content-wrapper">
    <div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
        <div class="rel">
    

  <!-- rellinks[1:] is an ugly hack to avoid link to module
  index -->
        <div class="rellink">
        <a href="feature_extraction.html"
        accesskey="P">Previous
        <br/>
        <span class="smallrellink">
        4.2. 特征提取
        </span>
            <span class="hiddenrellink">
            4.2. 特征提取
            </span>
        </a>
        </div>

    <!-- Ad a link to the 'up' page -->
        <div class="spacer">
        &nbsp;
        </div>
        <div class="rellink">
        <a href="../data_transforms.html">
        Up
        <br/>
        <span class="smallrellink">
        4. Dataset tr...
        </span>
            <span class="hiddenrellink">
            4. Dataset transformations
            </span>
            
        </a>
        </div>
    </div>
    
      <p class="doc-version">This documentation is for scikit-learn <strong>version 0.18</strong> &mdash; <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p>
    <p class="citing">If you use the software, please consider <a href="../about.html#citing-scikit-learn">citing scikit-learn</a>.</p>
    <ul>
<li><a class="reference internal" href="#">4.3. 数据预处理</a><ul>
<li><a class="reference internal" href="#variance-scaling">4.3.1. 标准化、去均值、方差缩放(variance scaling)</a><ul>
<li><a class="reference internal" href="#id6">4.3.1.1. 特征缩放至特定范围</a></li>
<li><a class="reference internal" href="#id13">4.3.1.2. 稀疏数据缩放</a></li>
<li><a class="reference internal" href="#id16">4.3.1.3. 含异常值数据缩放</a></li>
<li><a class="reference internal" href="#kernel-centering">4.3.1.4. 核矩阵中心化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#preprocessing-normalization">4.3.2. 规范化</a></li>
<li><a class="reference internal" href="#preprocessing-binarization">4.3.3. 二值化</a><ul>
<li><a class="reference internal" href="#id28">4.3.3.1. 特征二值化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#preprocessing-categorical-features">4.3.4. 分类特征编码</a></li>
<li><a class="reference internal" href="#imputation">4.3.5. 缺失值处理（Imputation）</a></li>
<li><a class="reference internal" href="#polynomial-features">4.3.6. 多项式特征生成</a></li>
<li><a class="reference internal" href="#id36">4.3.7. 装换器定制</a></li>
</ul>
</li>
</ul>

    </div>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" checked />
<label for="nav-trigger"></label>




      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="preprocessing">
<span id="id1"></span><h1>4.3. 数据预处理<a class="headerlink" href="#preprocessing" title="Permalink to this headline">¶</a></h1>
<p><a href="#id2"><span class="problematic" id="id3">``</span></a>sklearn.preprocessing``包为用户提供了多个工具函数和类，用于将原始特征转换成更适于项目后期学习的特征表示。</p>
<div class="section" id="variance-scaling">
<span id="preprocessing-scaler"></span><h2>4.3.1. 标准化、去均值、方差缩放(variance scaling)<a class="headerlink" href="#variance-scaling" title="Permalink to this headline">¶</a></h2>
<p>数据集的** 标准化 <strong>对于在scikit中的大部分机器学习算法来说都是一种</strong> 常规要求 ** 。如果单个特征没有或多或少地接近于标准正态分布：** 零均值和单位方差 <a href="#id4"><span class="problematic" id="id5">**</span></a>的高斯分布，那么它可能并不能在项目中表现出很好的性能。</p>
<p>在实际情况中,我们经常忽略特征的分布形状，直接经过去均值来对某个特征进行中心化，再通过除以非常量特征(non-constant features)的标准差进行缩放。</p>
<p>例如, 许多学习算法中目标函数的基础都是假设所有的特征都是零均值并且具有同一阶数上的方差(比如径向基函数、支持向量机以及L1L2正则化项等)。如果某个特征的方差比其他特征大几个数量级，那么它就会在学习算法中占据主导位置，导致学习器并不能像我们说期望的那样，从其他特征中学习。</p>
<p>工具函数:func:<cite>scale</cite> 为数组形状的数据集的标准化提供了一个快捷实现:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">preprocessing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_scaled</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X_scaled</span>                                          
<span class="go">array([[ 0.  ..., -1.22...,  1.33...],</span>
<span class="go">       [ 1.22...,  0.  ..., -0.26...],</span>
<span class="go">       [-1.22...,  1.22..., -1.06...]])</span>
</pre></div>
</div>
<p>经过缩放的数据集具有零均值和标准方差:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_scaled</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  0.])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X_scaled</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  1.,  1.])</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">preprocessing``模块也提供了一个实用类:class:`StandardScaler`</span> <span class="pre">,它使用</span> <span class="pre">``Transformer</span></code> 接口在训练集上计算均值和标准差，以便于在后续的测试集上进行相同的缩放.
This class is hence suitable for use in the early steps of a <a class="reference internal" href="generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal"><span class="pre">sklearn.pipeline.Pipeline</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span>
<span class="go">StandardScaler(copy=True, with_mean=True, with_std=True)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span><span class="o">.</span><span class="n">mean_</span>                                      
<span class="go">array([ 1. ...,  0. ...,  0.33...])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span><span class="o">.</span><span class="n">scale_</span>                                       
<span class="go">array([ 0.81...,  0.81...,  1.24...])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>                               
<span class="go">array([[ 0.  ..., -1.22...,  1.33...],</span>
<span class="go">       [ 1.22...,  0.  ..., -0.26...],</span>
<span class="go">       [-1.22...,  1.22..., -1.06...]])</span>
</pre></div>
</div>
<p>缩放类对象可以在新的数据上实现和训练集相同缩放操作:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>                
<span class="go">array([[-2.44...,  1.22..., -0.26...]])</span>
</pre></div>
</div>
<p>你也可以通过在构造函数:class:<cite>StandardScaler`中传入参数``with_mean=False`</cite> 或者``with_std=False``来取消中心化或缩放操作。</p>
<div class="section" id="id6">
<h3>4.3.1.1. 特征缩放至特定范围<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>另外一个可选的缩放操作是将特征缩放至给定的最小、最大值范围，经常是[0,1]。
或者也可以将每个特征的最大绝对值转换至单位大小。这两类操作可以分别通过使用:class:<a href="#id7"><span class="problematic" id="id8">`</span></a>MinMaxScaler`或者:class:<a href="#id9"><span class="problematic" id="id10">`</span></a>MaxAbsScaler`实现。</p>
<p>The motivation to use this scaling include robustness to very small
standard deviations of features and preserving zero entries in sparse data.</p>
<p>下面这个例子展示了将一个简单的数据矩阵缩放至``[0, 1]``范围:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_max_scaler</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">MinMaxScaler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_minmax</span> <span class="o">=</span> <span class="n">min_max_scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_minmax</span>
<span class="go">array([[ 0.5       ,  0.        ,  1.        ],</span>
<span class="go">       [ 1.        ,  0.5       ,  0.33333333],</span>
<span class="go">       [ 0.        ,  1.        ,  0.        ]])</span>
</pre></div>
</div>
<p>同样的转换实例可以被用与在训练过程中不可见的测试数据:实现和训练数据一致的缩放和移位操作:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test_minmax</span> <span class="o">=</span> <span class="n">min_max_scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test_minmax</span>
<span class="go">array([[-1.5       ,  0.        ,  1.66666667]])</span>
</pre></div>
</div>
<p>你也可以通过查看缩放器(scaler)的属性，来观察在训练集中学习到的转换操作的基本性质:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">min_max_scaler</span><span class="o">.</span><span class="n">scale_</span>                             
<span class="go">array([ 0.5       ,  0.5       ,  0.33...])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">min_max_scaler</span><span class="o">.</span><span class="n">min_</span>                               
<span class="go">array([ 0.        ,  0.5       ,  0.33...])</span>
</pre></div>
</div>
<p>如果:class:<cite>MinMaxScaler`被提供了一个精确的``feature_range=(min, max)`</cite>，完整的公式是:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">X_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

<span class="n">X_scaled</span> <span class="o">=</span> <span class="n">X_std</span> <span class="o">/</span> <span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">+</span> <span class="nb">min</span>
</pre></div>
</div>
<p><a class="reference internal" href="generated/sklearn.preprocessing.MaxAbsScaler.html#sklearn.preprocessing.MaxAbsScaler" title="sklearn.preprocessing.MaxAbsScaler"><code class="xref py py-class docutils literal"><span class="pre">MaxAbsScaler</span></code></a> 工作原理非常相似,但是它只通过除以每个特征的最大值将训练数据特征缩放至 <code class="docutils literal"><span class="pre">[-1,</span> <span class="pre">1]</span></code>。这就意味着，训练数据应该是已经零中心化或者是稀疏数据。
例子::用先前例子的数据实现最大绝对值缩放操作:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_abs_scaler</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">MaxAbsScaler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_maxabs</span> <span class="o">=</span> <span class="n">max_abs_scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train_maxabs</span>                <span class="c1"># doctest +NORMALIZE_WHITESPACE^</span>
<span class="go">array([[ 0.5, -1. ,  1. ],</span>
<span class="go">       [ 1. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  1. , -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test_maxabs</span> <span class="o">=</span> <span class="n">max_abs_scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test_maxabs</span>                 
<span class="go">array([[-1.5, -1. ,  2. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_abs_scaler</span><span class="o">.</span><span class="n">scale_</span>         
<span class="go">array([ 2.,  1.,  2.])</span>
</pre></div>
</div>
<p>如果你并不想创造一个对象，那么你可以通过使用:func:<cite>scale</cite>, <a class="reference internal" href="generated/sklearn.preprocessing.minmax_scale.html#sklearn.preprocessing.minmax_scale" title="sklearn.preprocessing.minmax_scale"><code class="xref py py-func docutils literal"><span class="pre">minmax_scale</span></code></a>, :func:<a href="#id11"><span class="problematic" id="id12">`</span></a>maxabs_scale`来快速实现缩放操作。</p>
</div>
<div class="section" id="id13">
<h3>4.3.1.2. 稀疏数据缩放<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>稀疏数据的中心化会破坏数据中的稀疏结构，因此很少有一个比较明智的实现方式。但是，对稀疏输入进行缩放操作是有意义的，特别是当特征的数值并不在同一个量级上面的时候。
<a class="reference internal" href="generated/sklearn.preprocessing.MaxAbsScaler.html#sklearn.preprocessing.MaxAbsScaler" title="sklearn.preprocessing.MaxAbsScaler"><code class="xref py py-class docutils literal"><span class="pre">MaxAbsScaler</span></code></a> 和:func:<cite>maxabs_scale</cite> 是稀疏数据缩放比较推荐的实现方式。
但是，<a class="reference internal" href="generated/sklearn.preprocessing.scale.html#sklearn.preprocessing.scale" title="sklearn.preprocessing.scale"><code class="xref py py-func docutils literal"><span class="pre">scale</span></code></a> 和 <a class="reference internal" href="generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler" title="sklearn.preprocessing.StandardScaler"><code class="xref py py-class docutils literal"><span class="pre">StandardScaler</span></code></a> 可以接收``scipy.sparse``矩阵作为输入,只要将参数``with_centering=False``传入构造函数。否则程序将会出现异常 <code class="docutils literal"><span class="pre">ValueError</span></code> 。
因为默认的中心化操作会破坏数据的稀疏性，并导致大量的内存占用。
<a class="reference internal" href="generated/sklearn.preprocessing.RobustScaler.html#sklearn.preprocessing.RobustScaler" title="sklearn.preprocessing.RobustScaler"><code class="xref py py-class docutils literal"><span class="pre">RobustScaler</span></code></a> 并不适用于稀疏数据，但是你可以在稀疏输入上使用the <a href="#id14"><span class="problematic" id="id15">``</span></a>transform``方法。</p>
<p>注意，缩放器既可以接收行压缩稀疏数据也可以是列压缩稀疏数据(参见``scipy.sparse.csr_matrix``和``scipy.sparse.csc_matrix``)。 其他形式的稀疏输入**会被转换为行压缩稀疏表示**。为了避免不必要的内存复制，推荐在顶层使用CSR或CSC表示。</p>
<p>最后，如果已经中心化的数据并不是很大，可以选择使用&#8217;&#8216;toarray&#8217;&#8216;方法将稀疏矩阵转换为数组。</p>
</div>
<div class="section" id="id16">
<h3>4.3.1.3. 含异常值数据缩放<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>如果你的数据包含较多的异常值，使用均值和方差缩放可能并不是一个很好的选择。在这种情况下，你可以使用
<a class="reference internal" href="generated/sklearn.preprocessing.robust_scale.html#sklearn.preprocessing.robust_scale" title="sklearn.preprocessing.robust_scale"><code class="xref py py-func docutils literal"><span class="pre">robust_scale</span></code></a> 和:class:<cite>RobustScaler</cite> 作为替代。它们使用更加鲁棒的中心和范围估计来缩放你的数据。</p>
<div class="topic">
<p class="topic-title first">参考:</p>
<p>Further discussion on the importance of centering and scaling data is
available on this FAQ: <a class="reference external" href="http://www.faqs.org/faqs/ai-faq/neural-nets/part2/section-16.html">Should I normalize/standardize/rescale the data?</a></p>
</div>
<div class="topic">
<p class="topic-title first">缩放 vs 白化</p>
<p>有时候单独地中心化和缩放并不是足够的，因为一些下层的学习算法还可能假设特征之间是线性独立的。</p>
<p>为了解决这个问题，你可以使用:class:<cite>sklearn.decomposition.PCA</cite>
或者:class:<cite>sklearn.decomposition.RandomizedPCA</cite> 带参数``whiten=True``来进一步移除特征之间的线性相关性。</p>
</div>
<div class="topic">
<p class="topic-title first">回归中的目标变量缩放</p>
<p><a class="reference internal" href="generated/sklearn.preprocessing.scale.html#sklearn.preprocessing.scale" title="sklearn.preprocessing.scale"><code class="xref py py-func docutils literal"><span class="pre">scale</span></code></a> and :class:<a href="#id17"><span class="problematic" id="id18">`</span></a>StandardScaler`可以对一维数组进行使用。这对于在回归当中的目标值或响应变量进行缩放时非常有效的。</p>
</div>
</div>
<div class="section" id="kernel-centering">
<span id="id19"></span><h3>4.3.1.4. 核矩阵中心化<a class="headerlink" href="#kernel-centering" title="Permalink to this headline">¶</a></h3>
<p>如果你有一个使用:math:<cite>phi`定义的核矩阵 :math:`K</cite>，用以计算特征空间上的内积，
:class:<a href="#id20"><span class="problematic" id="id21">`</span></a>KernelCenterer`可以用于核矩阵变换，变换后在特征空间的内积有一个已经去均值的:math:<a href="#id22"><span class="problematic" id="id23">`</span></a>phi`来定义。</p>
</div>
</div>
<div class="section" id="preprocessing-normalization">
<span id="id24"></span><h2>4.3.2. 规范化<a class="headerlink" href="#preprocessing-normalization" title="Permalink to this headline">¶</a></h2>
<p><strong>规范化是使单个样本具有单位范数的缩放操作。</strong> 这个在你使用二次型，比如点积或者其他核去定量计算任意样本对之间的相似性时是非常有用的。</p>
<p>规范化是向量空间模型
&lt;<a class="reference external" href="http://en.wikipedia.org/wiki/Vector_Space_Model">http://en.wikipedia.org/wiki/Vector_Space_Model</a>&gt;`_的基本假设，经常在文本分类和聚类当中使用。</p>
<p>方法 <a class="reference internal" href="generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" title="sklearn.preprocessing.normalize"><code class="xref py py-func docutils literal"><span class="pre">normalize</span></code></a> 为在数组类型的数据集提供了规范化的快速实现,可以选择``l1``或``l2``
范数:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_normalized</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X_normalized</span>                                      
<span class="go">array([[ 0.40..., -0.40...,  0.81...],</span>
<span class="go">       [ 1.  ...,  0.  ...,  0.  ...],</span>
<span class="go">       [ 0.  ...,  0.70..., -0.70...]])</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">preprocessing``模块也提供了实用类</span>
<span class="pre">:class:`Normalizer`</span> <span class="pre">，通过使用接口</span>
<span class="pre">``Transformer</span></code> 来实现相同的操作。(在这里``fit``方法并没有作用:
因为规范化类在面对不同的样本数据时是无状态独立的)。</p>
<p>This class is hence suitable for use in the early steps of a
<a class="reference internal" href="generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal"><span class="pre">sklearn.pipeline.Pipeline</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalizer</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">Normalizer</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># fit函数没有任何效果</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalizer</span>
<span class="go">Normalizer(copy=True, norm=&#39;l2&#39;)</span>
</pre></div>
</div>
<p>规范化实例可以在任意样本向量上实现:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>                            
<span class="go">array([[ 0.40..., -0.40...,  0.81...],</span>
<span class="go">       [ 1.  ...,  0.  ...,  0.  ...],</span>
<span class="go">       [ 0.  ...,  0.70..., -0.70...]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">normalizer</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>             
<span class="go">array([[-0.70...,  0.70...,  0.  ...]])</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">稀疏输入</p>
<p><a class="reference internal" href="generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" title="sklearn.preprocessing.normalize"><code class="xref py py-func docutils literal"><span class="pre">normalize</span></code></a> and :class:<a href="#id25"><span class="problematic" id="id26">`</span></a>Normalizer`**既可以接收稠密数组也可以接收scipy.sparse的稀疏矩阵作为输入。**</p>
<p>输入的稀疏数据**会被转化为行压缩稀疏表示** (参见``scipy.sparse.csr_matrix``)，然后再被送进Cython程序。为了避免不必要的内存复制，推荐在顶层使用CSR或CSC表示。</p>
</div>
</div>
<div class="section" id="preprocessing-binarization">
<span id="id27"></span><h2>4.3.3. 二值化<a class="headerlink" href="#preprocessing-binarization" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id28">
<h3>4.3.3.1. 特征二值化<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p><strong>特征二值化是将数值型特征变成布尔型特征</strong>。这对于当下层概率估计器假设输入数据是多变量` 伯努利分布&lt;<a class="reference external" href="http://en.wikipedia.org/wiki/Bernoulli_distribution">http://en.wikipedia.org/wiki/Bernoulli_distribution</a>&gt;`_ 时是非常有效的。
例如， <a class="reference internal" href="generated/sklearn.neural_network.BernoulliRBM.html#sklearn.neural_network.BernoulliRBM" title="sklearn.neural_network.BernoulliRBM"><code class="xref py py-class docutils literal"><span class="pre">sklearn.neural_network.BernoulliRBM</span></code></a>。</p>
<p>在文本处理中，即使规范化计数(a.k.a. term frequencies)或者TF-IDF数值特征在实际情况中性能略胜一筹，使用布尔型特征仍旧是是非常常见的(很大可能可以简化概率推演)。</p>
<p>和:class:<cite>Normalizer`一样，
:class:`Binarizer</cite> is meant to be used in the early stages of
<a class="reference internal" href="generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal"><span class="pre">sklearn.pipeline.Pipeline</span></code></a>. <code class="docutils literal"><span class="pre">fit</span></code> 也并没有作用，
因为样本之间都是独立对待的:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">binarizer</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">Binarizer</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># fit does nothing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binarizer</span>
<span class="go">Binarizer(copy=True, threshold=0.0)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">binarizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.,  1.],</span>
<span class="go">       [ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.]])</span>
</pre></div>
</div>
<p>可以改变二值器的阈值:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">binarizer</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">Binarizer</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">1.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binarizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  1.],</span>
<span class="go">       [ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
</pre></div>
</div>
<p>跟:class:<cite>StandardScaler`和:class:`Normalizer`类一样，模块也提供了二值化方法:func:`binarize</cite>，以便不需要转换接口时使用。</p>
</div>
</div>
<div class="section" id="preprocessing-categorical-features">
<span id="id29"></span><h2>4.3.4. 分类特征编码<a class="headerlink" href="#preprocessing-categorical-features" title="Permalink to this headline">¶</a></h2>
<p>特征更多的时候是分类特征，而不是连续的数值特征。
比如一个人的特征可以是``[&#8220;male&#8221;, &#8220;female&#8221;]``，
<code class="docutils literal"><span class="pre">[&quot;from</span> <span class="pre">Europe&quot;,</span> <span class="pre">&quot;from</span> <span class="pre">US&quot;,</span> <span class="pre">&quot;from</span> <span class="pre">Asia&quot;]</span></code>，
<code class="docutils literal"><span class="pre">[&quot;uses</span> <span class="pre">Firefox&quot;,</span> <span class="pre">&quot;uses</span> <span class="pre">Chrome&quot;,</span> <span class="pre">&quot;uses</span> <span class="pre">Safari&quot;,</span> <span class="pre">&quot;uses</span> <span class="pre">Internet</span> <span class="pre">Explorer&quot;]</span></code>。
这样的特征可以高效的编码成整数，例如
<code class="docutils literal"><span class="pre">[&quot;male&quot;,</span> <span class="pre">&quot;from</span> <span class="pre">US&quot;,</span> <span class="pre">&quot;uses</span> <span class="pre">Internet</span> <span class="pre">Explorer&quot;]``可以表示成</span>
<span class="pre">``[0,</span> <span class="pre">1,</span> <span class="pre">3]</span></code>，<code class="docutils literal"><span class="pre">[&quot;female&quot;,</span> <span class="pre">&quot;from</span> <span class="pre">Asia&quot;,</span> <span class="pre">&quot;uses</span> <span class="pre">Chrome&quot;]``就是``[1,</span> <span class="pre">2,</span> <span class="pre">1]</span></code>。</p>
<p>这个的整数特征表示并不能在scikit-learn的估计器中直接使用，因为这样的连续输入，估计器会认为类别之间是有序的，但实际却是无序的。(例如：浏览器的类别数据则是任意排序的)。</p>
<p>一个将分类特征转换成scikit-learn估计器可用特征的可选方法是使用one-of-K或者one-hot编码,该方法是:class:<cite>OneHotEncoder`的一个实现。该方法将每个类别特征的 ``m`</cite> 可能值转换成``m``个二进制特征值，当然只有一个是激活值。</p>
<p>续上例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">OneHotEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>  
<span class="go">OneHotEncoder(categorical_features=&#39;all&#39;, dtype=&lt;... &#39;float&#39;&gt;,</span>
<span class="go">       handle_unknown=&#39;error&#39;, n_values=&#39;auto&#39;, sparse=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[ 1.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  1.]])</span>
</pre></div>
</div>
<p>默认情况下，每个特征使用几维的数值由数据集自动推断。当然，你也可以通过使用参数``n_values``来精确指定。
在我们的例子数据集中，有两个可能得性别类别，三个洲，四个网络浏览器。接着，我们训练编码算法，并用来对一个样本数据进行转换。
在结果中，前两个数值是性别编码，紧接着的三个数值是洲编码，最后的四个数值是浏览器编码。</p>
<p>查询:参考:<cite>dict_feature_extraction</cite> 用于将类别数据标示为字典型数据，而不是整数。</p>
</div>
<div class="section" id="imputation">
<span id="id30"></span><h2>4.3.5. 缺失值处理（Imputation）<a class="headerlink" href="#imputation" title="Permalink to this headline">¶</a></h2>
<p>因为各种各样的原因，真实世界中的许多数据集都包含缺失数据，这类数据经常被编码成空格、NaNs，或者是其他的占位符。但是这样的数据集并不能scikit-learn学习算法兼容，因为大多的学习算法都默认假设数组中的元素都是数值，因而所有的元素都有自己的意义。
使用不完整的数据集的一个基本策略就是舍弃掉整行或整列包含缺失值的数据。但是这样就付出了舍弃可能有价值数据（即使是不完整的 ）的代价。
处理缺失数值的一个更好的策略就是从已有的数据推断出缺失的数值。</p>
<p>:class:<a href="#id31"><span class="problematic" id="id32">`</span></a>Imputer`类提供了缺失数值处理的基本策略，比如使用缺失数值所在行或列的均值、中位数、众数来替代缺失值。该类也兼容不同的缺失值编码。</p>
<p>接下来是一个如何替换缺失值的简单示例，缺失值被编码为``np.nan``, 使用包含缺失值的列的均值来替换缺失值。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">Imputer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp</span> <span class="o">=</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s1">&#39;NaN&#39;</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp</span><span class="o">.</span><span class="n">fit</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="go">Imputer(axis=0, copy=True, missing_values=&#39;NaN&#39;, strategy=&#39;mean&#39;, verbose=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">imp</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>                           
<span class="go">[[ 4.          2.        ]</span>
<span class="go"> [ 6.          3.666...]</span>
<span class="go"> [ 7.          6.        ]]</span>
</pre></div>
</div>
<p><a class="reference internal" href="generated/sklearn.preprocessing.Imputer.html#sklearn.preprocessing.Imputer" title="sklearn.preprocessing.Imputer"><code class="xref py py-class docutils literal"><span class="pre">Imputer</span></code></a> 类也支持稀疏矩阵:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp</span> <span class="o">=</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">Imputer(axis=0, copy=True, missing_values=0, strategy=&#39;mean&#39;, verbose=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_test</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">imp</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>                      
<span class="go">[[ 4.          2.        ]</span>
<span class="go"> [ 6.          3.666...]</span>
<span class="go"> [ 7.          6.        ]]</span>
</pre></div>
</div>
<p>注意，在这里，缺失数据被编码为0， and are thus implicitly stored
in the matrix. 这种方式用在当缺失数据比观察数据更多的情况时是非常合适的。</p>
<p><a class="reference internal" href="generated/sklearn.preprocessing.Imputer.html#sklearn.preprocessing.Imputer" title="sklearn.preprocessing.Imputer"><code class="xref py py-class docutils literal"><span class="pre">Imputer</span></code></a> can be used in a Pipeline as a way to build a composite
estimator that supports imputation. See <a class="reference internal" href="../auto_examples/missing_values.html#example-missing-values-py"><span class="std std-ref">Imputing missing values before building an estimator</span></a></p>
</div>
<div class="section" id="polynomial-features">
<span id="id33"></span><h2>4.3.6. 多项式特征生成<a class="headerlink" href="#polynomial-features" title="Permalink to this headline">¶</a></h2>
<p>很多情况下，考虑输入数据中的非线性特征来增加模型的复杂性是非常有效的。一个简单常用的方法就是使用多项式特征，它能捕捉到特征中高阶和相互作用的项。
:class:<a href="#id34"><span class="problematic" id="id35">`</span></a>PolynomialFeatures`类中可以实现该功能:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">PolynomialFeatures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>                                                 
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>                             
<span class="go">array([[  1.,   0.,   1.,   0.,   0.,   1.],</span>
<span class="go">       [  1.,   2.,   3.,   4.,   6.,   9.],</span>
<span class="go">       [  1.,   4.,   5.,  16.,  20.,  25.]])</span>
</pre></div>
</div>
<p>特征向量X从:math:<cite>(X_1, X_2)</cite> 被转换成:math:<cite>(1, X_1, X_2, X_1^2, X_1X_2, X_2^2)</cite>。</p>
<p>在一些情况中，我们只需要特征中的相互作用项(interaction terms)，它可以通过传入参数``interaction_only=True``获得:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>                                                 
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">interaction_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>                             
<span class="go">array([[   1.,    0.,    1.,    2.,    0.,    0.,    2.,    0.],</span>
<span class="go">       [   1.,    3.,    4.,    5.,   12.,   15.,   20.,   60.],</span>
<span class="go">       [   1.,    6.,    7.,    8.,   42.,   48.,   56.,  336.]])</span>
</pre></div>
</div>
<p>特征向量X从:math:<cite>(X_1, X_2, X_3)</cite> 被转换成:math:<cite>(1, X_1, X_2, X_3, X_1X_2, X_1X_3, X_2X_3, X_1X_2X_3)</cite>。</p>
<p>注意多项式特征被隐含地使用在`核方法&lt;<a class="reference external" href="http://en.wikipedia.org/wiki/Kernel_method">http://en.wikipedia.org/wiki/Kernel_method</a>&gt;`_ (例如， <a class="reference internal" href="generated/sklearn.svm.SVC.html#sklearn.svm.SVC" title="sklearn.svm.SVC"><code class="xref py py-class docutils literal"><span class="pre">sklearn.svm.SVC</span></code></a>, <a class="reference internal" href="generated/sklearn.decomposition.KernelPCA.html#sklearn.decomposition.KernelPCA" title="sklearn.decomposition.KernelPCA"><code class="xref py py-class docutils literal"><span class="pre">sklearn.decomposition.KernelPCA</span></code></a>) <a class="reference internal" href="svm.html#svm-kernels"><span class="std std-ref">Kernel functions</span></a>.</p>
<p>See <a class="reference internal" href="../auto_examples/linear_model/plot_polynomial_interpolation.html#example-linear-model-plot-polynomial-interpolation-py"><span class="std std-ref">Polynomial interpolation</span></a> for Ridge regression using created polynomial features.</p>
</div>
<div class="section" id="id36">
<h2>4.3.7. 装换器定制<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h2>
<p>你可能经常需要将一个已经存在的python函数转换成转换器以便于在数据清理和预处理当中使用。你可以通过:class:<a href="#id37"><span class="problematic" id="id38">`</span></a>FunctionTransformer`类将任意一个函数转换成转换器。
例如，创建一个实现对数变换的转换器，可以这么做:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">FunctionTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">FunctionTransformer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[ 0.        ,  0.69314718],</span>
<span class="go">       [ 1.09861229,  1.38629436]])</span>
</pre></div>
</div>
<p>对于使用:class:<cite>FunctionTransformer`去做特殊特征选择的完整代码示例可以:参考:`example_preprocessing_plot_function_transformer.py</cite></p>
</div>
</div>


          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer">
        &copy; 2010 - 2014, scikit-learn developers (BSD License).
      <a href="../_sources/modules/preprocessing.txt" rel="nofollow">Show this page source</a>
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="feature_extraction.html">Previous
      </a>
    </div>
    
     </div>

    
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-22606712-2']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    

    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
    <script type="text/javascript"> google.load('search', '1',
        {language : 'en'}); google.setOnLoadCallback(function() {
            var customSearchControl = new
            google.search.CustomSearchControl('016639176250731907682:tjtqbvtvij0');
            customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
            var options = new google.search.DrawOptions();
            options.setAutoComplete(true);
            customSearchControl.draw('cse', options); }, true);
    </script>
  </body>
</html>